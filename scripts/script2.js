// // // // let admin;
// // // // let name = "John";
// // // // admin = name;
// // // // alert(admin);
// // // let number = 4 > 2;
// // // alert(`Ghbdtn ${number}`);
// // alert("3" * "4");
// let rt = "";
// rt = Number(rt);
// alert(rt);

// // 1 случай
// // ++counter
// let counterPref = 1;
// // let a = ++counterPref;// сначала прибавляем к counterPref единицу, потом записываем counterPref в а
// counterPref++;// тоже самое, только построчно
// let a = counterPref;// тоже самое, только построчно
// console.log("counterPref", counterPref); // 2
// console.log("a", a); // 2
// console.log("//");
// // 2 случай
// // ++counter
// let counterPostfix = 1;
// // let a1 = counterPostfix++;// сначала записываем counterPostfix в a1, потом увеличиваем (инкрементируем) counterPostfix на 1
// let a1 = counterPostfix;// тоже самое, только построчно
// counterPostfix++;// тоже самое, только построчно
// console.log("counterPostfix", counterPostfix); // 2
// console.log("a1", a1); // 1

// let result;
// login == "Сотрудник"
//   ? (result = "Привет")
//   : login == "Директор"
//   ? (result = "Здравствуйте")
//   : login == " "
//   ? (result = "Нет логина")
//   : (result = "");
////////////////
// (что-то==чему-то)-это условие
// ?=если

// (а=б)-то вот это

// : = в противном случае

// (что-то !=чему-то)-это условие
// ?=если

// (а=с)-то вот это

// : = в противном случае
// (а!=с)
// ^
// |
// то же самое, только через if else

// if(что-то==чему-то){// если вот это условие верно, то
//     а=б // Отработает этот сценарий
// }else if(что-то !=чему-то){// в противном случае при верном исходе этого условия
//     а=с// отработает этот сценарий
// }
// else{ // вот это отработает, если не отработало НИЧЕГО выше.
//     а!=с
// }
// let a = prompt("hjjg");
// if (a < 5) {
//   alert("a меньше 5");
// } else if (a > 5) {
//   alert("a больше 5");
//   if (a % 2 === 0) {
//     alert("четное");
//   } else {
//     alert("нечтное");
//   }
// } else {
//   alert("a ппар 5");
// }

// a < 5
//   ? alert("a меньше 5")
//   : a > 5
//   ? (alert("a больше 5"), a % 2 === 0 ? alert("четное") : alert("нечетное"))
//   : a === 5 && alert("a ппар 5");

// let age = prompt("ghgfgh");
// if (age < 14 && age > 90) {// если age меньше 14 и (&&) больше 90, то age не находится в диапазоне
//   alert(`${age} не находится в диапазоне`);
// }

// let login = prompt("Введите логин"); // в переменную login записываем результат работы функции prompt
// console.log(login);
// if (login === "админ") {// если введенное с помощью prompt и записанное в переменную login значение равно "админ", то выполняем тело if-a ( то, что в фигурных скобках )
//   let result = prompt("Введите пароль");
//   if (result === "Я главный") {// в этом вложенном if-e логика такая-же как и сверху: если введенное с помощью prompt и записанное в переменную result значение равно "Я главный", то выполняем тело if-a ( то, что в фигурных скобках )
//     alert("Здравствуйте!");
//   } else if (result === null) {// если (result === null) - т.е. пользователь нажал на esc или на кнопку "отмена" и prompt вернул на null
//     alert("Отменено");
//   } else {// в противном случае показываем сообщение "неверный пароль"
//     alert("Неверный пароль");
//   }
// } else if (login === "" || login === null) {// если (login === null) - т.е. пользователь нажал на esc или на кнопку "отмена" и prompt вернул на null или ( || ) login === "" - т.е. пользователь ничего не ввел и нажал "ок"
//   alert("Отменено");
// } else {
//   alert("Я вас не знаю");
// }

// for (let i = 2; i <= 10; i++) {// в цикле с шагом - "1" от 2 до 10 включительно
//   if (i % 2 != 0) continue; // мы проверяем является ли переменная i на текущей итерации цикла четным числом, если не является, то пропускаем итерацию (continue)
//   alert(`${i} четное`); // вывод числа, т.к. сверху срабатывает continue, будет работать только для четных чисел
// }

// let result = prompt("Введите число больше 100");
// while (result < 100) { // пока result меньше 100, то просим пользователя ввести число еще раз на строке 114
//   result = prompt("Введите еще раз");
//   if (result === null) break; // если пользователь во время нахождения в prompt`e нажал esc или кнопку "отмена", то прерываем цикл while c  помощью break
// }

// let n = prompt("kfkfjrek");
// nextPrime:
// for (let i = 2; i <= n; i++) { // Для всех i...

//   for (let j = 2; j < i; j++) { // проверить, делится ли число..// интересно что в этом цикле они начинают с 2, т.к. смысла начинать с 1 нет, т.к. все числа делятся на 1 и проверять смысла нет
//     if (i % j == 0) continue nextPrime; // не подходит, берём следующее // если наше число делится на j без остатка, то оно не простое и мы прерываем внешний цикл
//   }

//   alert( i ); // простое число
// }
// let browser = prompt(`Введите имя браузера`);
// if (browser == `Edge`) {
//   alert(`You've got the Edge`);
// } else if (
//   browser == `Chrome` ||
//   browser == `FireFox` ||
//   browser == `Safari` ||
//   browser == `Opera`
// ) {
//   alert(`Okay we support these browsers too`);
// } else {
//   alert(`We hope that this page looks ok!`);
// }

// let number = +prompt("Введите число между 0 и 3", "");
// switch (number) { // закидываем в switch переменную number чтобы ее сверять с вариантами из case`ов
//   case 0: // eсли number равно 0, то  выводим alert
//     alert("Вы ввели число 0");
//     break; // и прерываем весь switch с помощью break
//   case 1: // если number равно 1, то выводим alert с другой инфой
//     alert("Вы ввели число 1");
//     break; // вышли из switch
//   case 2: // в случае, если number равен 2
//   case 3: // или 3
//     alert("Вы ввели число 2, а может и 3"); // то выводим вот это
//     break; // и выходим из switch
// }

// function checkAge(age) { // функция checkAge, в которую мы передали age
//   return age > 18 ? true : confirm(`Родители разрешили?`); // функция возвращает true, если age больше 18, в противном случае выводим confirm и уже по результатам, которые вернет confirm делаем какие-то вывод
// }
// let age = prompt("Укажите свой возраст");
// alert(checkAge(age));// вызываем функцию checkAge и передаем в нее age, результат работы функции выводим в алерте, результатом является то, что вернется из функции с помощью return

// let number = 3; // объявили переменную, равную трём, ее будем умножать на себя же n раз
// let n = 4; // n - количество раз перемножения number саму на себя
// let result = number * number * number * number; // умножили number саму на себя 4 раза (возвели number в 4 степень)
// console.log(result); // вывели результат умножения в консоль

// function min(a, b) { // создаем функцию min с параметрами a и b
//   return a < b ? a : b; // которая возвращает меньшее из двух чисел
// }
// console.log(min(-1, 5)); // выводим результат работы функции min в консоль

// let pow = function(x, n) { // объявляем функцию pow (function expression) и передаем в нее параметры x и n (x - число, которое будем возводить в степень, n - само число степени, в которую будем возводить)
//   let result = x; // объявили переменную result и записали в нее параметр функции x (это мы делаем для того, чтобы не изменять сам параметр x, а только использовать параметр х, т.к если мы будем его изменять, то у нас получится не возведение в степень вот так (3*3*3), а получится вот так (3*9*27) )
//   for (let i = 1; i < n; i++) { // далее мы создаем цикл, в котором будет количество итераций, равное числу степени, в которую мы возводим x (т.е. мы с помощью цикла, у которого количество итераций зависит от параметра n, можем умножать x на себя же такое количество раз, которое нам нужно)
//     result = result * x; // в переменную result записываем результат перемножения result на x. т.е. выглядеть это будет так (1 итерация(3*3) 2 итерация(9*3) 3 итерация не произойдет, т.к. у нас снизу функция pow вызывается с параметрами 3 и 3)
//     console.log(result); // выводим result в консоль
//   }
//   return result; // возвращаем result
// };
// console.log(pow(3, 3)); // выводим результат работы функции pow с параметрами 3 и 3 в консоль

// function ask(question, yes, no) { // создаем функцию ask, передаем в нее 3 параметра (строку и две функции)
//     if (confirm(question)) yes() // если confirm с переданным в него question возвращает true, то выполнится функция yes
//     else no(); // в противном случае выполнится функция no
//   }

//   ask( // вызов функции ask c переданными в нее строкой и двумя функциями
//     "Вы согласны?",
//     function() { alert("Вы согласились."); },
//     function() { alert("Вы отменили выполнение."); }
//   );

// let ask = (question, yes, no) => { // переписанный вариант ask под стрелочные функции ( делает все тоже самое, что и функция ask выше)
//   confirm(question) ? yes() : no();
// };
// console.log(
//   ask(
//     "Вы согласны?",
//     () => {
//       alert("Вы согласились.");
//     },
//     () => {
//       alert("Вы отменили выполнение.");
//     }
//   )
// );

// let user = { // создаем объект юзер с двумя свойствами. объекты хранят свойства (пары ключ-значение), где:
//// Ключи свойств должны быть строками или символами (обычно строками).
//// Значения могут быть любого типа.

//   name: "John", // name - key - ключ 'John' - значение - user[name]
//   surname: "Smith" //surname - key - ключ 'Smith' - значение - user[surname]
// };

// user.name = "Pete"; // изменили значение ключа name в объекте user на "Pete"
// delete user.name; // удалили ключ name, (и соответственно значение, которое было к нему привязано) из объекта user

// let schedule = {}; // создали пустой объект schedule

// function isEmpty(obj) { // coздаем функцию isEmpty, которая принимает параметр obj (в этот параметр АВТОМАТИЧЕСКИ (МАГИЧЕСКИ) записывается то, что мы в эту функцию передаем при ее вызове на строках 229 и 231)
//   for (key in obj) { // в цикле for...in перебираем параметр obj "поключно" ( за одну итерацию цикла работаем только с одним ключом)
//     if (obj[key] !== undefined) { // проверяем НЕ пустое ли ЗНАЧЕНИЕ, к которому мы обращаемся по ключу (обращение происходит вот так: obj[key]) т.е. это тоже самое что и user[surname], только в контексте цикла, где при каждой итерации цикла ключи объекта obj записываются в key для того, чтобы мы каждый раз не писали обращение к свойствам объекта вручную :)
//       return false; // возвращаем false () если значение НЕ пустое (это значит что и сам передаваемый в функцию объект не пустой)
//     }
//   }
//   return true; // возвращаем из функции true после цикла, т.к. если нас не выкинуло из цикла со значением false, то объект пуст, это мы и сообщаем в итоге
// }
// alert(isEmpty(schedule)); // true // вызываем в alert`e функцию isEmpty и передаем в нее schedule (в функции работать с schedule можно будет с помощью параметра obj)
// schedule["8:30"] = "get up"; // создаем в schedule key = "8:30" и значение этого key`я schedule["8:30"] = "get up".
// alert(isEmpty(schedule)); // false// eще раз вызываем в alert`e функцию isEmpty и передаем в нее уже измененный schedule (в функции работать с schedule можно будет с помощью параметра obj)
